# JOGA Analytics - Cursor Rules

## Project Overview
JOGA Analytics is a web application for coaches to visualize match data from Google Sheets. It provides interactive charts, analytics, and an AI-powered chatbot for natural language data queries.

## Tech Stack

### Frontend
- **Framework**: React 18 + TypeScript
- **Build Tool**: Vite
- **Styling**: Tailwind CSS
- **Charts**: Recharts
- **State Management**: React Context API
- **HTTP Client**: Fetch API with custom apiClient wrapper

### Backend
- **Framework**: Express.js + TypeScript
- **Database**: SQLite with Kysely (type-safe query builder)
- **Authentication**: Session-based with HttpOnly cookies + CSRF protection
- **Email**: SendGrid
- **AI**: Google Gemini API
- **Rate Limiting**: express-rate-limit

### Deployment
- **Platform**: Railway
- **Database**: SQLite (persistent filesystem on Railway)

## Project Structure

```
joga-visualizer/
‚îú‚îÄ‚îÄ backend/              # Backend Express API
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db/          # Database schema, migrations, Kysely setup
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/  # Auth, CSRF, rate limiting
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/      # API route handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/   # Business logic (auth, sheets, AI, etc.)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.ts    # Express app setup
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src/                  # Frontend React app
‚îÇ   ‚îú‚îÄ‚îÄ components/      # React components
‚îÇ   ‚îú‚îÄ‚îÄ contexts/        # React contexts (AuthContext)
‚îÇ   ‚îú‚îÄ‚îÄ services/        # API clients and business logic
‚îÇ   ‚îú‚îÄ‚îÄ types/           # TypeScript type definitions
‚îÇ   ‚îú‚îÄ‚îÄ utils/           # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ config.ts        # Configuration
‚îú‚îÄ‚îÄ docs/                # Documentation
‚îî‚îÄ‚îÄ package.json
```

## Coding Conventions

### TypeScript
- Use strict TypeScript with proper types
- Prefer interfaces over types for object shapes
- Use type-safe database queries with Kysely
- Avoid `any` - use `unknown` if type is truly unknown

### React
- Use functional components with hooks
- Prefer `useCallback` and `useMemo` for performance optimization
- Use Context API for global state (AuthContext)
- Keep components focused and single-purpose
- Use TypeScript for all component props

### Backend
- Use async/await for all async operations
- Use Kysely for all database queries (type-safe)
- Validate all user input
- Use middleware for cross-cutting concerns (auth, CSRF, rate limiting)
- Return consistent error responses: `{ error: string }`

### File Naming
- Components: PascalCase (e.g., `LoginPage.tsx`)
- Services/utilities: camelCase (e.g., `authService.ts`)
- Types: camelCase (e.g., `types.ts`, `auth.ts`)
- Routes: camelCase (e.g., `auth.ts`, `sheets.ts`)

## Architecture Patterns

### Authentication
- **Session-based** with HttpOnly cookies (secure, not accessible to JavaScript)
- **CSRF protection** using tokens in non-HttpOnly cookies
- **Middleware**: `authenticateSession` checks for session cookie or `X-Session-ID` header
- **Production**: Cookies use `sameSite: 'none'` for cross-origin (Railway frontend/backend on different domains)
- **Roles**: admin, coach, viewer with role-based access control

### Database
- **SQLite** with Kysely for type-safe queries
- **Migrations**: Automatic on server start, also manual via `npm run migrate`
- **Schema**: Defined in `backend/src/db/schema.ts` using Kysely types
- **Queries**: All database access through service layer, never direct queries in routes

### API Design
- **RESTful** endpoints under `/api/*`
- **Authentication**: Required for most endpoints (except `/auth/login`, `/auth/setup`)
- **Error Handling**: Consistent JSON error responses
- **CORS**: Configured for frontend origin, credentials enabled
- **‚ö†Ô∏è Cross-Origin Note**: Railway hosts frontend/backend on different domains - CORS and CSRF must be configured for cross-origin requests

### Frontend-Backend Communication
- **API Client**: `src/services/apiClient.ts` handles all HTTP requests
- **Credentials**: Always include cookies (`credentials: 'include'`)
- **CSRF**: Automatically included for state-changing requests (POST, PUT, DELETE)
- **Error Handling**: Centralized in apiClient, throws errors with messages

### Google Sheets Integration
- **Backend-only**: API keys stored in backend environment variables
- **Proxy Pattern**: Frontend calls backend API, backend calls Google Sheets API
- **Authentication**: Sheet routes require user authentication
- **Public Sheets**: API key authentication (no OAuth needed)

## Key Patterns

### Service Layer Pattern
- Business logic in services (e.g., `authService.ts`, `sheetsService.ts`)
- Routes are thin - they call services and return responses
- Services handle validation, database queries, external API calls

### Error Handling
- **Backend**: Try-catch in routes, return appropriate HTTP status codes
- **Frontend**: Try-catch in service calls, display user-friendly error messages
- **Logging**: Console logs for debugging (use emoji prefixes: üìä, üîí, ‚ùå, ‚úÖ)

### Environment Variables
- **Backend**: `.env` file in `backend/` directory
- **Frontend**: `VITE_*` prefix for Vite environment variables
- **Production**: Set in Railway dashboard
- **Never commit**: Add to `.gitignore`

### Type Safety
- **Database**: Kysely provides full type safety for queries
- **API**: TypeScript interfaces for request/response types
- **Frontend**: Type-safe API client with generics

## Important Notes

### ‚ö†Ô∏è PRE-DEPLOYMENT CHECKLIST - CRITICAL FOR RAILWAY

**BEFORE PUSHING TO GITHUB, ALWAYS VERIFY:**

1. **CSRF Token Configuration (Cross-Origin Critical)**
   - ‚úÖ CSRF token cookies must use `sameSite: 'none'` in production (Railway hosts frontend/backend on different domains)
   - ‚úÖ CSRF token cookies must have `secure: true` in production (required for `sameSite: 'none'`)
   - ‚úÖ Frontend must be able to read CSRF token (non-HttpOnly cookie) OR fetch from API response headers
   - ‚úÖ Check `backend/src/middleware/csrf.ts` - `setCsrfTokenCookie` function uses correct `sameSite` value
   - ‚úÖ Check `backend/src/routes/auth.ts` - login/setup routes set CSRF token with correct `sameSite` value
   - ‚úÖ Verify `X-CSRF-Token` header is being sent with state-changing requests (POST, PUT, DELETE)
   - ‚ö†Ô∏è **Common Issue**: If CSRF token cookie uses `sameSite: 'strict'` in production, cookies won't be sent cross-origin ‚Üí 403 errors

2. **CORS Configuration**
   - ‚úÖ CORS must allow frontend origin with `credentials: true`
   - ‚úÖ Check `backend/src/server.ts` - CORS configuration includes frontend domain
   - ‚úÖ Verify `Access-Control-Allow-Credentials: true` header is set
   - ‚úÖ Verify `Access-Control-Allow-Origin` matches frontend domain (not wildcard `*` when using credentials)

3. **Cross-Origin Cookie Considerations**
   - ‚ö†Ô∏è **Railway hosts frontend and backend on different domains** (e.g., `joga-analytics.up.railway.app` for backend, different domain for frontend)
   - ‚ö†Ô∏è JavaScript **cannot read cookies from different domains** - use API response headers (`X-CSRF-Token`) for CSRF tokens in cross-origin scenarios
   - ‚úÖ Session cookies (HttpOnly) are sent automatically by browser, but CSRF tokens (non-HttpOnly) may need special handling
   - ‚úÖ Check `src/services/apiClient.ts` - CSRF token retrieval handles cross-origin scenarios

4. **Testing Checklist**
   - ‚úÖ Test state-changing API calls (PUT, POST, DELETE) in production environment
   - ‚úÖ Verify CSRF token is included in request headers
   - ‚úÖ Check browser console for CSRF-related errors (403 Forbidden)
   - ‚úÖ Verify cookies are being set and sent correctly (check Network tab ‚Üí Request Headers)

**If you see "CSRF token required" or 403 errors after deployment:**
1. Check CSRF middleware cookie settings (`sameSite: 'none'` in production)
2. Verify frontend can access CSRF token (cookie or API header)
3. Check CORS configuration allows credentials
4. Review `backend/src/middleware/csrf.ts` and `backend/src/routes/auth.ts` for cookie settings

### Railway Deployment
- **Trust Proxy**: Set to `1` (trust only first proxy)
- **Rate Limiting**: Configured with `validate: { trustProxy: false }` to avoid warnings
- **Cookies**: `sameSite: 'none'` in production for cross-origin support
- **Port**: Railway sets `PORT` automatically, don't set manually
- **Database**: SQLite file persists on Railway filesystem

### Security
- **Passwords**: Hashed with bcryptjs
- **Sessions**: HttpOnly cookies (not accessible to JavaScript)
- **CSRF**: Token-based protection for state-changing requests
- **Rate Limiting**: Applied to auth endpoints
- **CORS**: Restricted to frontend origin
- **API Keys**: Never in frontend code, only backend environment variables

### Google Sheets
- **Environment Variables**: `GOOGLE_SHEETS_SPREADSHEET_ID` and `GOOGLE_SHEETS_API_KEY`
- **Public Sheets**: API key is sufficient
- **Private Sheets**: Would require OAuth/service account (not currently implemented)
- **Diagnostic Endpoint**: `/api/sheets/test` for troubleshooting

### AI Integration
- **Gemini API**: Used for chatbot functionality
- **Environment Variable**: `GEMINI_API_KEY` in backend
- **Service**: `backend/src/services/aiService.ts` and `src/services/geminiService.ts`

## Common Tasks

### Adding a New API Endpoint
1. Create route handler in `backend/src/routes/`
2. Add business logic to service in `backend/src/services/`
3. Add route to `backend/src/server.ts`
4. Create frontend service function in `src/services/`
5. Use `apiGet`, `apiPost`, etc. from `apiClient.ts`

### Adding a New Chart Component
1. Create component in `src/components/`
2. Use Recharts for visualization
3. Handle missing data gracefully
4. Add to chart selector/grouping logic
5. Follow existing chart component patterns

### Database Migration
1. Create migration file in `backend/src/db/migrations/`
2. Use Kysely migration API
3. Run `npm run migrate` in backend directory
4. Migrations run automatically on server start

### Adding Environment Variables
1. **Backend**: Add to `backend/.env` and Railway dashboard
2. **Frontend**: Add with `VITE_` prefix, add to Railway dashboard
3. **Documentation**: Update relevant README or docs

## Code Style Preferences

- **Indentation**: 2 spaces
- **Quotes**: Single quotes for JavaScript/TypeScript
- **Semicolons**: Yes
- **Trailing Commas**: Yes in objects/arrays
- **Arrow Functions**: Preferred for callbacks
- **Async/Await**: Preferred over Promises.then()
- **Console Logs**: Use emoji prefixes for easy log filtering (üìä, üîí, ‚úÖ, ‚ùå, ‚ö†Ô∏è)

## Testing & Debugging

- **Backend Logs**: Check Railway deployment logs
- **Frontend Logs**: Browser console
- **Database**: SQLite file at `backend/data/joga.db` (local) or Railway filesystem (production)
- **API Testing**: Use `/api/health` and `/api/config/check` endpoints
- **Sheets Testing**: Use `/api/sheets/test` diagnostic endpoint

## When Making Changes

1. **Follow existing patterns** - look at similar code for consistency
2. **Update types** - ensure TypeScript types are updated
3. **Handle errors** - always include error handling
4. **Log appropriately** - use console logs with emoji prefixes
5. **Test locally** - verify changes work before pushing
6. **Update docs** - if adding features, update relevant documentation
7. **‚ö†Ô∏è CHECK CSRF & CORS** - Before pushing, verify CSRF token and CORS configuration work in cross-origin scenarios (see Pre-Deployment Checklist above)
